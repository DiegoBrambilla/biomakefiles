include /marconi_work/mBI20_AmbCo/diego/biomakefiles/lib/make/makefile.diamond
include /marconi_work/mBI20_AmbCo/diego/biomakefiles/lib/make/makefile.misc

# DIAMOND-specific macros
MAKECALL_DIAMOND_DEEPARG = $(MAKECALL_VERSION); $(MAKECALL_PARAMS); $(MAKECALL_DB_DEEPARG); $(MAKECALL_INFILES)
MAKECALL_DB_DEEPARG      = echo "	Database: $(DIAMOND_DB_PATH)/arg (`ls -lL $(DIAMOND_DB_PATH)/arg.dmnd`)" >> $@.makecall
DIAMOND_ALIGN_OPTS = --id 90 --evalue 0.00001 -f $(OUTFMT) 
OUTFMT= 6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovhsp
DIAMOND_DB_PATH = arg_db
DIAMOND_DB = /marconi_scratch/userexternal/afranzet/icme9/arg_db/arg
#deeparg.py specific macro: define minimum a.a. alignemnt length threshold
ALENGTH = 37.5


# From: https://github.com/erikrikarddaniel/biomakefiles/blob/master/doc/running_diamond_megan.md
# There doesn't seem to be a way of producing one meganized daa file from two input daa files.
# It's therefore preferable to run Diamond on an interleaved fastq file (can be gzipped) containing both reads from each pair.
# To interleave sequences, look in the makefile.misc file. 


# *** Misc Targets *** 

# Compress with gzip a .fastq file
#%.fastq.gz: %.fastq
#	gzip -c $< > $@

%.intlv.fastq.gz: %.R1.fastq.gz %.R2.fastq.gz
	python interleave_fastq.py $^ | gzip -c > $@

%.intlv.fastq: %.R1.fastq %.R2.fastq
	python interleave_fastq.py $^ > $@

# Interleave two fastq files (named %.R1.fastq and %.R2.fastq respectively).
#
# The target uses a python script -- interleave_fastq.py -- cloned from this
# gist:
#
#   https://gist.github.com/rpucheq/cf50eeea794529ca6b0e
#  *** Warning! ***
# The aforementioned script works for bot .gzip and uncompressed files
# but it has been written in PYTHON 2!!!
#
# Dependencies will automatically be unzipped if not present in unzipped format
# thanks to the pattern above. Unzipped files will be deleted after
# interleaving.
interleave_all_fastq.gzs: $(subst .R1.fastq.gz,.intlv.fastq.gz,$(wildcard *.R1.fastq.gz))

# The same, but not zipping
interleave_all_fastqs: $(subst .R1.fastq,.intlv.fastq,$(wildcard *.R1.fastq))

# Running the Diamond aligner
#

# Non-generic databases (requires the DIAMOND_DB to be set to the full path,
# except the .dmnd suffix, of the database file).

# *** DIAMOND targets ***

%.argdb.m8: %.fastq.gz
	$(MAKECALL_DIAMOND_DEEPARG)
	diamond blastx -d $(DIAMOND_DB) --query $< -o $@ $(DIAMOND_ALIGN_OPTS)
	echo "`date +"%Y-%m-%d %H:%M:%S"`: DONE" >> $@.makecall
#same pattern for a different target (.fna files)

%.argdb.m8: %.fna
	$(MAKECALL_DIAMOND_DEEPARG)
	diamond blastx -d $(DIAMOND_DB) --query $< -o $@ $(DIAMOND_ALIGN_OPTS)
	echo "`date +"%Y-%m-%d %H:%M:%S"`: DONE" >> $@.makecall

%.argdb.sort.best.m8: %.argdb.m8
	echo -E "`date +"%Y-%m-%d %H:%M:%S"`: --->sorting $><--"
	sort -u -k1,1 $< > $@

%.argdb.filter.sort.best.m8: %.argdb.sort.best.m8
	echo -E "`date +"%Y-%m-%d %H:%M:%S"`: --->filtering $><--"
	python deeparg.py $< $(ALENGTH) $@

%.genelist.tsv: %.m8
	echo -E "`date +"%Y-%m-%d %H:%M:%S"`: --->sorting $><--"
	cut -f 1,2 $< | sed 's/|/\t/g' | sort -u -k6,6 - > $@

# *** Make rules ***
# compress all .fastq files in the work directory.
compress_all_fastqs: $(subst .fastq,.fastq.gz, $(wildcard *.fastq))

# parses DIAMOND m8 matrix to get unique tab-separated hits
sort_best_m8: $(subst .argdb.m8,.argdb.sort.best.m8, $(wildcard *.argdb.m8))

#filters out DIAMOND m8 matrix to select hits based on alignment length cutoff (input)
# N.B.: depends on the python script "deeparg.py" that requires python 3.6*-3.8* (see also required dependencies at the top of the file)
argdb_alength_filter: $(subst .argdb.m8,.argdb.filter.sort.best.m8, $(wildcard *.argdb.m8))

# parses DIMAOND m8 matrix to get an annotated gene list
sort_argdb_genelist_tsv: $(subst .argdb.m8,.genelist.tsv, $(wildcard *.argdb..m8))

# Nucleotides in fastq file against the NCBI RefSeq protein database
fastq2arg_db.m8s: $(subst .fastq.gz,.argdb.m8,$(wildcard *.fastq.gz)) $(subst .fna,.argdb.m8,$(wildcard *.fna))

