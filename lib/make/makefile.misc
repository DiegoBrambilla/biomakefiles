# makefile.misc
#
# Library makefile containing various simple pattern rules which doesn't fit
# anywhere else.
#
# Include the full path of this file in your Makefile ...
#
# Author: erik.rikard.daniel@gmail.com

SHELL := /bin/bash

# Some general purpose macros

# Concate a number of gzipped files and write to a gzipped file.
CONCAT_GZIPPED = gunzip -c $^ | gzip -c > $@

# *** Targets ***

# Interleave two fastq files (named %.r1.fastq and %.r2.fastq respectively).
#
# The target uses a python script -- interleave_fastq.py -- cloned from this
# gist:
#
#   https://gist.github.com/rpucheq/cf50eeea794529ca6b0e
#
# Dependencies will automatically be unzipped if not present in unzipped format
# thanks to the pattern above. Unzipped files will be deleted after
# interleaving.
interleave_all_fastq.gzs: $(subst .r1.fastq.gz,.intlv.fastq.gz,$(wildcard *.r1.fastq.gz))

%.intlv.fastq.gz: %.r1.fastq %.r2.fastq
	interleave_fastq.py $^ | gzip -c > $@

# The same, but not zipping
interleave_all_fastqs: $(subst .r1.fastq,.intlv.fastq,$(wildcard *.r1.fastq))

%.intlv.fastq: %.r1.fastq %.r2.fastq
	interleave_fastq.py $^ > $@
	
# Concatenate instead of interleave
%.concat.fastq.gz: %.r1.fastq.gz %.r2.fastq.gz
	$(CONCAT_GZIPPED)

# Clean up a fasta file so that names does not contain spaces, dashes and other
# characters that cause problems in various programs. Also places sequences on
# one line so that one can more easily select sequences with grep.
CLEAN_FASTA = awk '/^>/ {printf("\n%s\n",$$0);next; } { printf("%s",$$0);} END {printf("\n");}' | sed '/^$$/d' | sed '/^>/s/[ \t]\+/_/g' | sed '/^>/s/[-(),:;+|]//g'

%.c.fna: %.fna
	cat $< | $(CLEAN_FASTA) > $@

%.c.faa: %.faa
	cat $< | $(CLEAN_FASTA) > $@

%.c.alnfna: %.alnfna
	cat $< | $(CLEAN_FASTA) > $@

%.c.alnfaa: %.alnfaa
	cat $< | $(CLEAN_FASTA) > $@

# Transform fasta files to tab separated tables (keeping the ">")
SEQTSV = cat $< | paste - - > $@

%.na.tsv: %.fna
	$(SEQTSV)

%.aa.tsv: %.faa
	$(SEQTSV)

%.alnna.tsv: %.alnfna
	$(SEQTSV)

%.alnaa.tsv: %.alnfaa
	$(SEQTSV)

ONLY_ACCNO = sed '/^>/s/>.*\(_accno_\)\|\(@\)\(.*\)/>\3/' $< > $@

%.only_accno.faa: %.faa
	$(ONLY_ACCNO)

%.only_accno.faa: %.faa
	$(ONLY_ACCNO)

%.phylip: %.alnfaa
	echo "$$(grep -c '>' $<) $$(grep -v '>' $< | head -n 1 | awk '{ print length($$1); }')" > $@
	awk '/^>(.*)/ { printf("%s ", substr($$1, 2)); next; } !/^>/ { print $$0; }' $< >> $@

fastqgzs2seqlens: $(subst .fastq.gz,.seqlens.tsv,$(wildcard *.fastq.gz))

all_seqlens: $(subst .fastq.gz,.seqlens.tsv,$(wildcard *.fastq.gz)) $(subst .fna.gz,.seqlens.tsv,$(wildcard *.fna.gz)) $(subst .fna,.seqlens.tsv,$(wildcard *.fna))

%.seqlens.tsv: %.fastq.gz
	echo "seqlen	n" > $@
	gunzip -c $< | awk 'NR%4 == 2 {lengths[length($0)]++} END {for (l in lengths) {print l,"\t",lengths[l]}}' | sed 's/ *//g' >> $@

%.seqlens.tsv: %.fna.gz
	echo "seqlen	n" > $@
	gunzip -c $< | awk 'NR%2 == 0 {lengths[length($0)]++} END {for (l in lengths) {print l,"\t",lengths[l]}}' | sed 's/ *//g' >> $@

%.seqlens.tsv: %.fna
	echo "seqlen	n" > $@
	awk 'NR%2 == 0 {lengths[length($0)]++} END {for (l in lengths) {print l,"\t",lengths[l]}}' $< | sed 's/ *//g' >> $@

r1.seqcounts.tsv: $(subst .fastq.gz,.seqcount,$(wildcard *.r1.fastq.gz))
	for f in $^; do \
	  echo "$$(basename $$f .r1.seqcount)	$$(cat $$f)"; \
	done > $@
%.seqcount: %.fastq.gz
	echo $$(expr $$(gunzip -c $< | wc -l) / 4) > $@

%.fna: %.fna.gz
	gunzip -c $< > $@

%.fna: %.fastq.gz
	gunzip -c $< | fastq_to_fasta > $@

# Count the total number of nucleotides in a set of .fna files
numnucl.tsv: $(subst .fna,.numnucl.tsv,$(wildcard *.fna))
	cat $^ > $@

%.numnucl.tsv: %.fna
	echo "$<	$$(grep -v '>' $< | tr -d '\n' | awk '{ print length; }')" > $@

# Mask a multiple alignment. Uses the maskaln.r script from the
# https://github.com/erikrikarddaniel/maskaln repo.

MASKALN_OPTS =

%.masked.alnfaa: %.alnfaa %.protect
	maskaln.r --protect_taxa $(word 2,$^) $(MASKALN_OPTS) $< $@

%.masked.alnfaa: %.alnfaa
	maskaln.r $(MASKALN_OPTS) $< $@
